# Things that difficult with Webpack

(This is a work in progress, feel free to make a pull request with suggestions.)

These are things which make working with Webpack more difficult.

- Setting a project root. Webpack allows you to set a project root, so that you can use absolute require paths. (`require('foo/bar')` instead of `require('../foo/bar)` from `baz/zee.js`). This seems great of the surface, but it makes testing more difficult, since Node doesn't support setting the root, and even if it did, it would require duplicate configuration for both Node and Webpack. This is a problem for testing since most unit testing tools run on Node. It may be possible to work around this with a Node package which extends require().
- Using ES2015 `import` syntax (compiled to CommonJS). The [Loader specification](https://github.com/whatwg/loader) is very incomplete. What this means is that code you write using import and compile with Babel to CommonJS is very likely to break once the loader spec is actually completed. While it might work out ok to keep using it, it breaks one of the main conventions of Babel ES2015 compiling. Babel lets you use *spec-complient* code in *non*-spec-complient browsers. This holds completely true for all ES2015 (and now ES2016 with that preset) features. You can use thing's like fat arrow functions and destructuring years before the browser compatability will catch up. But, as soon as it does, you can stop compiling those features and use the browser's native implementation. With import, this isn't the case. If you compile import to CommonJS, then Babel stops being the syntax equivalent of a polyfill, and becomes a library dependency for your project. An example of why this is a problem is if Babel was replaced by another tool which did the same same syntax compiling job for ES2015, but which either ignored import or used a different model (which is would be free to do, since compiling to CommonJS is not a specification). If you used import, you would not be able to cleanly upgrade to this tool, since you are dependent on Babel's handling of import, even though everything else (which follows the convention and specifications) would work perfectly.
- Using CommonJS. Using CommonJS can be difficult to get started with if on the front end if you aren't already familiar with it. A lot of example code uses import syntax (because people didn't get the above memo), so you need to be able to translate in your head one to the other.
